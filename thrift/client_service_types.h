/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef client_service_TYPES_H
#define client_service_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace celestial {

struct OwnershipMode {
  enum type {
    IncludeOwned = 0,
    ExcludeOwned = 1
  };
};

extern const std::map<int, const char*> _OwnershipMode_VALUES_TO_NAMES;

struct PickUpPolicy {
  enum type {
    RANDOM = 0,
    OLDEST = 1
  };
};

extern const std::map<int, const char*> _PickUpPolicy_VALUES_TO_NAMES;

class TaskInfo;

class QueryRequest;

class QueryResponse;

class GetTaskCountRequest;

class GetTaskCountResponse;

class QueryAndOwnRequest;

class QueryAndOwnResponse;

class UpdateRequest;

class UpdateResponse;

typedef struct _TaskInfo__isset {
  _TaskInfo__isset() : task_id(false), group(false), creation_time(false), owner(false), eta(false), value(false) {}
  bool task_id :1;
  bool group :1;
  bool creation_time :1;
  bool owner :1;
  bool eta :1;
  bool value :1;
} _TaskInfo__isset;

class TaskInfo {
 public:

  TaskInfo(const TaskInfo&);
  TaskInfo& operator=(const TaskInfo&);
  TaskInfo() : task_id(0), group(), creation_time(0), owner(), eta(0), value() {
  }

  virtual ~TaskInfo() throw();
  int64_t task_id;
  std::string group;
  int64_t creation_time;
  std::string owner;
  int64_t eta;
  std::string value;

  _TaskInfo__isset __isset;

  void __set_task_id(const int64_t val);

  void __set_group(const std::string& val);

  void __set_creation_time(const int64_t val);

  void __set_owner(const std::string& val);

  void __set_eta(const int64_t val);

  void __set_value(const std::string& val);

  bool operator == (const TaskInfo & rhs) const
  {
    if (__isset.task_id != rhs.__isset.task_id)
      return false;
    else if (__isset.task_id && !(task_id == rhs.task_id))
      return false;
    if (!(group == rhs.group))
      return false;
    if (!(creation_time == rhs.creation_time))
      return false;
    if (!(owner == rhs.owner))
      return false;
    if (!(eta == rhs.eta))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TaskInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TaskInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TaskInfo &a, TaskInfo &b);

inline std::ostream& operator<<(std::ostream& out, const TaskInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _QueryRequest__isset {
  _QueryRequest__isset() : group(false), limit(false), own_mode(false) {}
  bool group :1;
  bool limit :1;
  bool own_mode :1;
} _QueryRequest__isset;

class QueryRequest {
 public:

  QueryRequest(const QueryRequest&);
  QueryRequest& operator=(const QueryRequest&);
  QueryRequest() : group(), limit(0), own_mode((OwnershipMode::type)0) {
  }

  virtual ~QueryRequest() throw();
  std::string group;
  int32_t limit;
  OwnershipMode::type own_mode;

  _QueryRequest__isset __isset;

  void __set_group(const std::string& val);

  void __set_limit(const int32_t val);

  void __set_own_mode(const OwnershipMode::type val);

  bool operator == (const QueryRequest & rhs) const
  {
    if (!(group == rhs.group))
      return false;
    if (!(limit == rhs.limit))
      return false;
    if (!(own_mode == rhs.own_mode))
      return false;
    return true;
  }
  bool operator != (const QueryRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const QueryRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(QueryRequest &a, QueryRequest &b);

inline std::ostream& operator<<(std::ostream& out, const QueryRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _QueryResponse__isset {
  _QueryResponse__isset() : ret_status(false), tasks(false) {}
  bool ret_status :1;
  bool tasks :1;
} _QueryResponse__isset;

class QueryResponse {
 public:

  QueryResponse(const QueryResponse&);
  QueryResponse& operator=(const QueryResponse&);
  QueryResponse() : ret_status(0) {
  }

  virtual ~QueryResponse() throw();
  bool ret_status;
  std::vector<TaskInfo>  tasks;

  _QueryResponse__isset __isset;

  void __set_ret_status(const bool val);

  void __set_tasks(const std::vector<TaskInfo> & val);

  bool operator == (const QueryResponse & rhs) const
  {
    if (!(ret_status == rhs.ret_status))
      return false;
    if (!(tasks == rhs.tasks))
      return false;
    return true;
  }
  bool operator != (const QueryResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const QueryResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(QueryResponse &a, QueryResponse &b);

inline std::ostream& operator<<(std::ostream& out, const QueryResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _GetTaskCountRequest__isset {
  _GetTaskCountRequest__isset() : group(false), limit(false), own_mode(false) {}
  bool group :1;
  bool limit :1;
  bool own_mode :1;
} _GetTaskCountRequest__isset;

class GetTaskCountRequest {
 public:

  GetTaskCountRequest(const GetTaskCountRequest&);
  GetTaskCountRequest& operator=(const GetTaskCountRequest&);
  GetTaskCountRequest() : group(), limit(0), own_mode((OwnershipMode::type)0) {
  }

  virtual ~GetTaskCountRequest() throw();
  std::string group;
  int32_t limit;
  OwnershipMode::type own_mode;

  _GetTaskCountRequest__isset __isset;

  void __set_group(const std::string& val);

  void __set_limit(const int32_t val);

  void __set_own_mode(const OwnershipMode::type val);

  bool operator == (const GetTaskCountRequest & rhs) const
  {
    if (!(group == rhs.group))
      return false;
    if (!(limit == rhs.limit))
      return false;
    if (!(own_mode == rhs.own_mode))
      return false;
    return true;
  }
  bool operator != (const GetTaskCountRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetTaskCountRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetTaskCountRequest &a, GetTaskCountRequest &b);

inline std::ostream& operator<<(std::ostream& out, const GetTaskCountRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _GetTaskCountResponse__isset {
  _GetTaskCountResponse__isset() : ret_status(false), count(false) {}
  bool ret_status :1;
  bool count :1;
} _GetTaskCountResponse__isset;

class GetTaskCountResponse {
 public:

  GetTaskCountResponse(const GetTaskCountResponse&);
  GetTaskCountResponse& operator=(const GetTaskCountResponse&);
  GetTaskCountResponse() : ret_status(0), count(0) {
  }

  virtual ~GetTaskCountResponse() throw();
  bool ret_status;
  int32_t count;

  _GetTaskCountResponse__isset __isset;

  void __set_ret_status(const bool val);

  void __set_count(const int32_t val);

  bool operator == (const GetTaskCountResponse & rhs) const
  {
    if (!(ret_status == rhs.ret_status))
      return false;
    if (!(count == rhs.count))
      return false;
    return true;
  }
  bool operator != (const GetTaskCountResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetTaskCountResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetTaskCountResponse &a, GetTaskCountResponse &b);

inline std::ostream& operator<<(std::ostream& out, const GetTaskCountResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _QueryAndOwnRequest__isset {
  _QueryAndOwnRequest__isset() : group(false), limit(false), policy(false), lease_period_seconds(false), worker_name(false) {}
  bool group :1;
  bool limit :1;
  bool policy :1;
  bool lease_period_seconds :1;
  bool worker_name :1;
} _QueryAndOwnRequest__isset;

class QueryAndOwnRequest {
 public:

  QueryAndOwnRequest(const QueryAndOwnRequest&);
  QueryAndOwnRequest& operator=(const QueryAndOwnRequest&);
  QueryAndOwnRequest() : group(), limit(0), policy((PickUpPolicy::type)0), lease_period_seconds(0), worker_name() {
  }

  virtual ~QueryAndOwnRequest() throw();
  std::string group;
  int32_t limit;
  PickUpPolicy::type policy;
  int32_t lease_period_seconds;
  std::string worker_name;

  _QueryAndOwnRequest__isset __isset;

  void __set_group(const std::string& val);

  void __set_limit(const int32_t val);

  void __set_policy(const PickUpPolicy::type val);

  void __set_lease_period_seconds(const int32_t val);

  void __set_worker_name(const std::string& val);

  bool operator == (const QueryAndOwnRequest & rhs) const
  {
    if (!(group == rhs.group))
      return false;
    if (!(limit == rhs.limit))
      return false;
    if (!(policy == rhs.policy))
      return false;
    if (!(lease_period_seconds == rhs.lease_period_seconds))
      return false;
    if (!(worker_name == rhs.worker_name))
      return false;
    return true;
  }
  bool operator != (const QueryAndOwnRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const QueryAndOwnRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(QueryAndOwnRequest &a, QueryAndOwnRequest &b);

inline std::ostream& operator<<(std::ostream& out, const QueryAndOwnRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _QueryAndOwnResponse__isset {
  _QueryAndOwnResponse__isset() : ret_status(false), tasks(false) {}
  bool ret_status :1;
  bool tasks :1;
} _QueryAndOwnResponse__isset;

class QueryAndOwnResponse {
 public:

  QueryAndOwnResponse(const QueryAndOwnResponse&);
  QueryAndOwnResponse& operator=(const QueryAndOwnResponse&);
  QueryAndOwnResponse() : ret_status(0) {
  }

  virtual ~QueryAndOwnResponse() throw();
  bool ret_status;
  std::vector<TaskInfo>  tasks;

  _QueryAndOwnResponse__isset __isset;

  void __set_ret_status(const bool val);

  void __set_tasks(const std::vector<TaskInfo> & val);

  bool operator == (const QueryAndOwnResponse & rhs) const
  {
    if (!(ret_status == rhs.ret_status))
      return false;
    if (!(tasks == rhs.tasks))
      return false;
    return true;
  }
  bool operator != (const QueryAndOwnResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const QueryAndOwnResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(QueryAndOwnResponse &a, QueryAndOwnResponse &b);

inline std::ostream& operator<<(std::ostream& out, const QueryAndOwnResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _UpdateRequest__isset {
  _UpdateRequest__isset() : deletions(false), inserts(false), worker_name(false) {}
  bool deletions :1;
  bool inserts :1;
  bool worker_name :1;
} _UpdateRequest__isset;

class UpdateRequest {
 public:

  UpdateRequest(const UpdateRequest&);
  UpdateRequest& operator=(const UpdateRequest&);
  UpdateRequest() : worker_name() {
  }

  virtual ~UpdateRequest() throw();
  std::vector<TaskInfo>  deletions;
  std::vector<TaskInfo>  inserts;
  std::string worker_name;

  _UpdateRequest__isset __isset;

  void __set_deletions(const std::vector<TaskInfo> & val);

  void __set_inserts(const std::vector<TaskInfo> & val);

  void __set_worker_name(const std::string& val);

  bool operator == (const UpdateRequest & rhs) const
  {
    if (!(deletions == rhs.deletions))
      return false;
    if (!(inserts == rhs.inserts))
      return false;
    if (!(worker_name == rhs.worker_name))
      return false;
    return true;
  }
  bool operator != (const UpdateRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UpdateRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(UpdateRequest &a, UpdateRequest &b);

inline std::ostream& operator<<(std::ostream& out, const UpdateRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _UpdateResponse__isset {
  _UpdateResponse__isset() : ret_status(false), tasks(false) {}
  bool ret_status :1;
  bool tasks :1;
} _UpdateResponse__isset;

class UpdateResponse {
 public:

  UpdateResponse(const UpdateResponse&);
  UpdateResponse& operator=(const UpdateResponse&);
  UpdateResponse() : ret_status(0) {
  }

  virtual ~UpdateResponse() throw();
  bool ret_status;
  std::vector<TaskInfo>  tasks;

  _UpdateResponse__isset __isset;

  void __set_ret_status(const bool val);

  void __set_tasks(const std::vector<TaskInfo> & val);

  bool operator == (const UpdateResponse & rhs) const
  {
    if (!(ret_status == rhs.ret_status))
      return false;
    if (!(tasks == rhs.tasks))
      return false;
    return true;
  }
  bool operator != (const UpdateResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UpdateResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(UpdateResponse &a, UpdateResponse &b);

inline std::ostream& operator<<(std::ostream& out, const UpdateResponse& obj)
{
  obj.printTo(out);
  return out;
}

} // namespace

#endif
